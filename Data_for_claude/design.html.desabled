<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hero Section - No Animations</title>
    <style>
      /* Local font: Dream Avenue (kept as optional fallback) */
      @font-face {
        font-family: "Dream Avenue";
        src: url("./fonts/Dream-Avenue.ttf") format("truetype");
        font-weight: 400 900;
        font-style: normal;
        font-display: swap;
      }
      /* Local font: Brush Nature */
      @font-face {
        font-family: "Brush Nature";
        src: url("./fonts/BrushNature-Regular.otf") format("opentype");
        font-weight: 400;
        font-style: normal;
        font-display: swap;
      }
      /* Local font: Modern Avenue Demo */
      @font-face {
        font-family: "Modern Avenue";
        src: url("./fonts/Modern%20Avenue%20Demo.otf") format("opentype");
        font-weight: 400 700;
        font-style: normal;
        font-display: swap;
      }
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: #ffffff;
        color: #000000;
        font-family: "Arial", sans-serif;
        overflow-x: hidden;
      }

      body.no-scroll {
        overflow: hidden;
        height: 100vh;
      }

      /* HERO SECTION CONTAINER */
      .hero-section {
        height: 390vh; /* matches animation duration (2.9 + ~1 for gallery/text animations) */
        position: relative;
        background: #ffffff;
      }

      .hero-sticky {
        position: relative;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
      }

      /* HERO TEXT CONTAINER */
      .hero-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10;
        white-space: nowrap;
        font-family: "Dream Avenue", serif;
      }

      /* TEXT LINES EXACTLY LIKE SCREENSHOT */
      .text-line {
        font-size: clamp(4rem, 12vw, 16rem);
        font-weight: 900;
        line-height: 0.85;
        text-transform: uppercase;
        letter-spacing: -0.05em;
        color: #000000;
        margin-bottom: 0.1em;
      }

      /* Ensure per-character spans are inline-block so we can animate Y/blur per char */
      .text-line span {
        display: inline-block;
        white-space: pre;
        will-change: transform, opacity, filter;
      }

      /* Overlay text that animates with gallery items */
      .hero-overlay-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(
          calc(-50% - 200px),
          calc(-50% - 40px)
        ); /* pushed left 200px total, up 40px */
        z-index: 30;
        text-align: center;
        pointer-events: none;
        will-change: transform, opacity;
        max-width: 90vw;
      }

      .overlay-line {
        display: block;
        font-family: "Modern Avenue", "Brush Nature", "Dream Avenue", serif;
        font-size: clamp(4.2rem, 9vw, 7.4rem);
        font-weight: 700;
        color: #ffffff;
        line-height: 1.4;
        /* keep overlay lines as a single line to avoid unintended word-breaks */
        white-space: nowrap;
        overflow-wrap: normal;
        word-break: keep-all;
        hyphens: none;
        text-shadow: 0 0 20px rgba(0, 0, 0, 0.9), 0 0 40px rgba(0, 0, 0, 0.7),
          2px 2px 4px rgba(0, 0, 0, 0.8), -1px -1px 2px rgba(0, 0, 0, 0.6);
        -webkit-text-stroke: 1px rgba(0, 0, 0, 0.3);
      }

      .overlay-line:first-child {
        text-align: center;
        margin-bottom: 0.5em;
      }

      .overlay-char {
        display: inline-block;
        opacity: 0;
        transform: translateY(40px);
        will-change: transform, opacity;
      }

      /* Minimal CTA styles */
      .hero-cta {
        position: absolute; /* placed to right and pushed down */
        right: 100px;
        top: calc(50% + 150px);
        transform: translateY(-50%);
        display: inline-flex;
        align-items: center;
        gap: 0.8rem;
        padding: 1rem 1.6rem; /* increase size */
        border-radius: 0; /* remove rounded corners */
        background: rgba(0, 0, 0, 0.35); /* lighter background */
        color: #fff;
        border: 1px solid rgba(255, 255, 255, 0.08);
        text-decoration: none;
        font-weight: 700;
        font-size: 1.1rem; /* bigger */
        transform-origin: center;
        opacity: 0; /* start hidden */
        will-change: transform, opacity;
        transition: transform 220ms cubic-bezier(0.2, 0.9, 0.2, 1),
          box-shadow 180ms ease, background 180ms ease;
        z-index: 40;
      }

      .hero-cta:focus,
      .hero-cta:hover {
        transform: translateY(-3px) scale(1.02);
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.45);
        background: rgba(0, 0, 0, 0.6);
        outline: none;
      }

      /* CTA arrow small spacing */
      .hero-cta .cta-arrow {
        opacity: 0.9;
      }
      /* CTA responsive: move to bottom center on smaller screens */
      @media (max-width: 768px) {
        .hero-cta {
          right: 50%;
          left: auto;
          transform: translateX(50%);
          bottom: 8vh;
          top: auto;
        }
      }

      .line-1 {
        text-align: left;
      }

      .line-2 {
        text-align: center;
      }

      .line-3 {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 2rem;
      }

      /* VIDEO IN THE EXACT POSITION */
      .video-space {
        width: 300px;
        height: 180px;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
        flex-shrink: 0;
        position: relative;
        z-index: 5;
      }

      .video-space video {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      /* GALLERY VISIBLE FROM TOP CENTER (initially above viewport) */
      .gallery {
        position: absolute;
        top: -50px; /* 50px above the viewport/hero top */
        left: 50%; /* center horizontally */
        transform: translateX(-50%);
        display: flex;
        flex-wrap: nowrap;
        gap: 40px; /* doubled from 20px */
        z-index: 20;
        opacity: 1;
        /* removed transform3d to preserve translateX(-50%) */
        will-change: transform, opacity;
      }

      /* Prevent FOIC (flash of incorrectly positioned content) while JS initializes */
      .no-js .gallery,
      .no-js .gallery-item {
        visibility: hidden;
      }

      /* GALLERY FINAL POSITION AT BOTTOM */
      .gallery-bottom {
        position: absolute;
        bottom: 5vh;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        flex-wrap: nowrap;
        gap: 15px;
        z-index: 30;
        width: auto;
      }

      .gallery-item {
        width: 120px;
        height: 120px;
        border-radius: 10px;
        overflow: hidden;
        opacity: 1;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        flex-shrink: 0;
        /* initial transform removed; GSAP will set initial offsets */
        transition: box-shadow 300ms ease; /* transitions on transform removed to avoid FOIC on initial set */
        will-change: transform, opacity;
      }

      .gallery-item img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      /* HOVER & FOCUS STATES */
      .gallery-item:focus,
      .gallery-item:hover {
        transform: translateY(-6px) scale(1.06);
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.25);
        outline: none;
      }

      /* NEXT SECTION */
      .next-section {
        height: 100vh;
        background: #f5f5f5;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 3rem;
        color: #333;
      }

      /* RESPONSIVE */
      @media (max-width: 768px) {
        .text-line {
          font-size: clamp(3rem, 10vw, 8rem);
        }

        .video-space {
          width: 250px;
          height: 150px;
        }

        .line-3 {
          gap: 1rem;
        }
        .gallery-item {
          width: 90px;
          height: 90px;
        }
        /* Hide gallery items after the 3rd on mobile so animations stay focused */
        .gallery-item:nth-child(n + 4) {
          display: none;
        }
        .gallery {
          gap: 24px;
        } /* responsive reduced gap for small screens */
        /* Make overlay font smaller and allow wrapping on very narrow screens */
        .overlay-line {
          font-size: clamp(1.6rem, 5vw, 3rem);
          white-space: normal;
        }
        .hero-section {
          height: 300vh;
        }
      }
    </style>
  </head>
  <body class="no-js">
    <!-- HERO SECTION -->
    <section class="hero-section">
      <div class="hero-sticky">
        <!-- HERO TEXT EXACTLY LIKE SCREENSHOT -->
        <div class="hero-text">
          <div class="text-line line-1">BUILDING</div>
          <div class="text-line line-2">TOMORROW</div>
          <div class="text-line line-3">
            <span>FOR</span>
            <!-- VIDEO SPACE EXACTLY WHERE MARKED -->
            <div class="video-space">
              <video autoplay muted loop playsinline>
                <source src="./images/hero1.mp4" type="video/mp4" />
                <source
                  src="https://www.w3schools.com/html/mov_bbb.mp4"
                  type="video/mp4"
                />
              </video>
            </div>
            <span>TODAY</span>
          </div>
        </div>

        <!-- Overlay text that animates with gallery items -->
        <div
          class="hero-overlay-text"
          aria-label="Find your space to live fully."
        >
          <div class="overlay-line" data-text="Find your space"></div>
          <div class="overlay-line" data-text="to live fully."></div>

          <!-- Minimal CTA: animates with overlay text -->
          <!-- CTA removed from overlay and re-placed as a separate element below for right-side placement -->
        </div>

        <!-- GALLERY FROM TOP CENTER (initial state: 50px above viewport) -->
        <div class="gallery" style="visibility: hidden">
          <div class="gallery-item">
            <img src="./images/l11.jpg" alt="Gallery 1" />
          </div>
          <div class="gallery-item">
            <img src="./images/l4.jpg" alt="Gallery 2" />
          </div>
          <div class="gallery-item">
            <img src="./images/l5.jpg" alt="Gallery 3" />
          </div>
          <div class="gallery-item">
            <img src="./images/l6.jpg" alt="Gallery 4" />
          </div>
          <div class="gallery-item">
            <img src="./images/l8.jpg" alt="Gallery 5" />
          </div>
          <div class="gallery-item">
            <img
              src="./images/pexels-asphotography-94818.jpg"
              alt="Gallery 6"
            />
          </div>
          <div class="gallery-item">
            <img src="./images/pexels-fotoaibe-1571460.jpg" alt="Gallery 7" />
          </div>
          <div class="gallery-item">
            <img src="./images/pexels-jvdm-1457842.jpg" alt="Gallery 8" />
          </div>
        </div>
        <!-- CTA: placed on right side of hero-sticky, animates along with gallery and overlay -->
        <a
          class="hero-cta"
          href="#next-section"
          role="button"
          aria-label="Explore Homes"
        >
          Explore Homes
          <svg
            class="cta-arrow"
            width="20"
            height="20"
            viewBox="0 0 24 24"
            fill="none"
            aria-hidden="true"
          >
            <path
              d="M5 12h14M13 5l7 7-7 7"
              stroke="currentColor"
              stroke-width="1.6"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
        </a>
      </div>
    </section>

    <!-- NEXT SECTION -->
    <section class="next-section">
      <h2>Welcome to Next Section</h2>
    </section>

    <!-- GSAP SCRIPTS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>

    <script>
      // REGISTER GSAP PLUGIN
      gsap.registerPlugin(ScrollTrigger);

      // ============================================
      // ðŸŽ›ï¸ ANIMATION CONTROL KNOBS - ADJUST THESE!
      // ============================================

      const ANIMATION_CONTROLS = {
        // Video Expansion Settings
        videoScrollDistance: 2.9, // How many viewport scrolls for video to fully expand (1 = one scroll, 1.5 = one and a half scrolls, etc.)
        videoExpandSpeed: 1.2, // Duration of video expansion animation (higher = slower, try 1.0 to 2.5)
        videoScrubSmooth: 1, // How smooth scroll maps to animation (0.5 = very smooth, 2 = more direct, try 0.5 to 3)

        // Gallery Animation Settings
        galleryItemStagger: 0.12, // Delay between each gallery item appearing (higher = slower cascade, try 0.05 to 0.4)
        galleryItemDuration: 0.45, // How fast each gallery item animates in (higher = slower, try 0.3 to 1.0)
        galleryItemOffset: -70, // How far above viewport each item starts (higher = further up, try -50 to -120)

        // Text Animation Settings
        textCharStagger: 0.04,
        textCharInDuration: 0.6,
        textCharOutDuration: 0.5,
        textCharBlur: 10,

        // Timing Adjustments
        galleryStartDelay: 0.15, // Delay before gallery items start animating (relative to video expansion)
        textRevealDelay: 0.3, // Delay before text comes back (relative to video expansion)

        // Overlay text animation (exact match to text1.html)
        overlayCharStagger: 0.05, // 50ms per character for wave effect
        overlayCharDuration: 0.4, // fast per-character animation
        overlayCharEase: "back.out(2)", // bouncy/springy feel
        overlayStartY: 40, // characters start 40px below
      };

      // ============================================

      // ELEMENTS
      const heroSection = document.querySelector(".hero-section");
      const videoSpace = document.querySelector(".video-space");
      const heroText = document.querySelector(".hero-text");
      const gallery = document.querySelector(".gallery");
      const allGalleryItems = gsap.utils.toArray(".gallery-item");
      // galleryItems will contain the active items we animate (first 3 on mobile)
      let galleryItems = allGalleryItems.slice();
      const overlayText = document.querySelector(".hero-overlay-text");
      const overlayLines = gsap.utils.toArray(".overlay-line");

      // --- TEXT CHAR SPLITTING AND INITIAL ANIMATION ---
      const textLine1 = document.querySelector(".line-1");
      const textLine2 = document.querySelector(".line-2");
      const textLine3Spans = gsap.utils.toArray(".line-3 > span");

      function splitTextToChars(el) {
        if (!el) return;
        const text = el.textContent || "";
        // If already split, don't double-wrap
        if (el.querySelector("span")) return;
        // Save text for accessibility so we don't break screen readers
        el.setAttribute("aria-label", text.trim());
        el.innerHTML = "";
        text.split("").forEach((char) => {
          const ch = document.createElement("span");
          ch.textContent = char === " " ? "\u00A0" : char; // preserve spaces
          // Hide per-char spans from screen readers (we preserve the full text as aria-label)
          ch.setAttribute("aria-hidden", "true");
          el.appendChild(ch);
        });
      }

      function splitLine3ChildSpans() {
        textLine3Spans.forEach((s) => splitTextToChars(s));
      }

      // Split overlay lines into characters (matching text1.html approach)
      function splitOverlayToChars() {
        overlayLines.forEach((line) => {
          const text = line.getAttribute("data-text") || "";
          line.textContent = "";
          const chars = [];
          for (let i = 0; i < text.length; i++) {
            const ch = text[i];
            const span = document.createElement("span");
            span.classList.add("overlay-char");
            span.setAttribute("aria-hidden", "true");
            span.textContent = ch === " " ? "\u00A0" : ch;
            line.appendChild(span);
            chars.push(span);
          }
        });
      }

      // Execute initial splits
      splitTextToChars(textLine1);
      splitTextToChars(textLine2);
      splitLine3ChildSpans();
      splitOverlayToChars();

      function animateHeroTextInitial() {
        const chars = gsap.utils.toArray(".hero-text .text-line span");
        // Hide initially to avoid FOIC
        gsap.set(chars, {
          opacity: 0,
          y: 20,
          filter: `blur(${ANIMATION_CONTROLS.textCharBlur}px)`,
        });
        gsap.to(chars, {
          opacity: 1,
          y: 0,
          filter: "blur(0px)",
          stagger: ANIMATION_CONTROLS.textCharStagger,
          duration: ANIMATION_CONTROLS.textCharInDuration,
          ease: "power2.out",
        });
      }

      // Call animation immediately on load (after images are loaded will also re-build)
      window.addEventListener("load", () => {
        // small delay so styles load
        setTimeout(animateHeroTextInitial, 60);
      });

      // Hover effects for gallery items (subtle GSAP interactions) - attach once
      // Attach events to allGalleryItems so hover still works when items are present
      allGalleryItems.forEach((item) => {
        item.addEventListener("pointerenter", () => {
          gsap.to(item, { scale: 1.08, duration: 0.3, ease: "power3.out" });
        });
        item.addEventListener("pointerleave", () => {
          gsap.to(item, { scale: 1, duration: 0.25, ease: "power3.out" });
        });
        // keyboard accessible focus
        item.addEventListener("focus", () =>
          gsap.to(item, { scale: 1.06, duration: 0.3 })
        );
        item.addEventListener("blur", () =>
          gsap.to(item, { scale: 1, duration: 0.25 })
        );
      });

      // CALCULATE VIDEO POSITION AND SCALE
      function calculateVideoTransform() {
        const rect = videoSpace.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const viewportCenterX = window.innerWidth / 2;
        const viewportCenterY = window.innerHeight / 2;

        // Calculate how much to translate to center the video
        const translateX = viewportCenterX - centerX;
        const translateY = viewportCenterY - centerY;

        // Calculate scale to fill viewport (ensure it goes full width)
        const scaleX = window.innerWidth / rect.width;
        const scaleY = window.innerHeight / rect.height;
        const scale = Math.max(scaleX, scaleY) * 1.0; // scale to exactly fill viewport

        return { translateX, translateY, scale };
      }

      // CALCULATE GALLERY MOVE TO BOTTOM CENTER
      function calculateGalleryTransform() {
        const rect = gallery.getBoundingClientRect();
        const galleryCenterX = rect.left + rect.width / 2;
        const galleryCenterY = rect.top + rect.height / 2;
        const targetCenterX = window.innerWidth / 2;
        // 5vh above bottom
        const targetCenterY = window.innerHeight - window.innerHeight * 0.05;

        const translateX = targetCenterX - galleryCenterX;
        const translateY = targetCenterY - galleryCenterY;
        return { translateX, translateY };
      }

      // TIMELINE CONTAINER
      let videoTimeline;

      // BUILD TIMELINES (idempotent - kills previous)
      function buildTimelines() {
        // clear previous timelines
        if (videoTimeline) {
          videoTimeline.kill();
        }

        // Reset inline transforms (safer on rebuild)
        gsap.set(videoSpace, { clearProps: "all" });

        const transform = calculateVideoTransform();
        const galleryTransform = calculateGalleryTransform();
        // Ensure heroSection height matches timeline end (video scroll distance + 1 viewport)
        const desiredHeight = Math.ceil(
          (ANIMATION_CONTROLS.videoScrollDistance + 1) * window.innerHeight
        );
        heroSection.style.height = `${desiredHeight}px`;
        // Determine active gallery items based on viewport
        const isMobileView = window.matchMedia("(max-width: 768px)").matches;
        if (isMobileView) {
          galleryItems = allGalleryItems.slice(0, 3);
        } else {
          galleryItems = allGalleryItems.slice();
        }

        // ANCHOR TIMELINE: VIDEO EXPANDS AND STAYS FULL-SIZE;
        // LATER (ON FURTHER SCROLL) GALLERY + TEXT ANIMATIONS PLAY
        videoTimeline = gsap.timeline({
          scrollTrigger: {
            trigger: heroSection,
            start: "top top",
            end: () =>
              `+=${
                window.innerHeight * ANIMATION_CONTROLS.videoScrollDistance
              }`, // controlled by videoScrollDistance
            scrub: ANIMATION_CONTROLS.videoScrubSmooth, // controlled by videoScrubSmooth
            pin: ".hero-sticky", // pin the hero-sticky until timeline finishes so user can't scroll past
            pinSpacing: true,
            anticipatePin: 0.5,
          },
        });

        // PHASE 1: Expand video and de-emphasize text
        videoTimeline
          .to(
            videoSpace,
            {
              x: transform.translateX,
              y: transform.translateY,
              scale: transform.scale,
              borderRadius: 0,
              zIndex: 1000,
              duration: ANIMATION_CONTROLS.videoExpandSpeed, // controlled by videoExpandSpeed
              ease: "power2.inOut",
            },
            0
          )
          .to(
            ".line-1, .line-2, .line-3 span",
            {
              scale: 0.7,
              opacity: 0.3,
              duration: 1.0,
              ease: "power2.out",
            },
            0
          )
          // Per character: animate blur + Y while fading out so it matches the "text.html" look
          .to(
            ".hero-text .text-line span",
            {
              opacity: 0.35,
              y: -14,
              filter: `blur(${ANIMATION_CONTROLS.textCharBlur}px)`,
              duration: ANIMATION_CONTROLS.textCharOutDuration,
              stagger: ANIMATION_CONTROLS.textCharStagger,
              ease: "sine.in",
            },
            0
          );

        // After the video is expanded (later in the same scroll), run gallery and reveal text
        // Label ensures these run after the video expansion portion of the timeline
        // Set label later so gallery and text reveal start after video expansion
        videoTimeline.addLabel("afterExpand", 1.3);

        // GALLERY slides to bottom-center with staggered item reveal
        videoTimeline
          .to(
            gallery,
            {
              x: galleryTransform.translateX,
              y: galleryTransform.translateY,
              duration: 0.4, // slightly longer so the gallery takes more scroll to move
              ease: "power7.inOut",
            },
            "afterExpand"
          )
          .to(videoSpace, { zIndex: 5, duration: 0.5 }, "afterExpand")
          // Example animation variants you can try for galleryItems. Uncomment one and comment out
          // the default `.to(galleryItems, ...)` block to experiment.
          // 1) Slide from right & fade in (snappy)
          // gsap.from(galleryItems, { x: 140, autoAlpha: 0, stagger: { each: 0.12, from: 'start' }, duration: 0.45, ease: 'power3.out' }, 'afterExpand+=0.15');
          // 2) Scale + fade in
          // gsap.from(galleryItems, { scale: 0.85, autoAlpha: 0, stagger: { each: 0.12, from: 'start' }, duration: 0.5, ease: 'back.out(1.2)' }, 'afterExpand+=0.15');
          // 3) Rotate in with subtle 3D
          // gsap.from(galleryItems, { rotationX: -15, autoAlpha: 0, transformOrigin: 'center center', stagger: { each: 0.12, from: 'start' }, duration: 0.5, ease: 'power2.out' }, 'afterExpand+=0.15');

          .to(
            galleryItems,
            {
              y: 0,
              scale: 1,
              stagger: {
                each: ANIMATION_CONTROLS.galleryItemStagger,
                from: "start",
              }, // controlled by galleryItemStagger
              duration: ANIMATION_CONTROLS.galleryItemDuration, // controlled by galleryItemDuration
              ease: "power3.inout",
            },
            `afterExpand+=${ANIMATION_CONTROLS.galleryStartDelay}` // controlled by galleryStartDelay
          )
          // Animate overlay text with wave/bounce effect (starts exactly with gallery items)
          .fromTo(
            ".overlay-char",
            {
              opacity: 0,
              y: ANIMATION_CONTROLS.overlayStartY,
            },
            {
              opacity: 1,
              y: 0,
              duration: ANIMATION_CONTROLS.overlayCharDuration,
              ease: ANIMATION_CONTROLS.overlayCharEase,
              stagger: ANIMATION_CONTROLS.overlayCharStagger,
              force3D: true,
            },
            `afterExpand+=${ANIMATION_CONTROLS.galleryStartDelay}` // exact same start as gallery
          )
          // Animate CTA at the same start (a subtle fade+rise)
          .to(
            ".hero-cta",
            {
              opacity: 1,
              y: 0,
              scale: 1,
              duration: 0.4,
              ease: "power2.out",
            },
            `afterExpand+=${ANIMATION_CONTROLS.galleryStartDelay}`
          )
          // Bring text back to normal and also add parallax offsets
          .to(
            ".line-1, .line-2, .line-3 span",
            {
              scale: 1,
              opacity: 1,
              duration: 0.6,
              ease: "power2.out",
            },
            `afterExpand+=${ANIMATION_CONTROLS.textRevealDelay}` // controlled by textRevealDelay
          )
          // Per-character: remove blur + Y and restore opacity
          .to(
            ".hero-text .text-line span",
            {
              opacity: 1,
              y: 0,
              filter: "blur(0px)",
              duration: ANIMATION_CONTROLS.textCharInDuration,
              stagger: ANIMATION_CONTROLS.textCharStagger,
              ease: "sine.out",
            },
            `afterExpand+=${ANIMATION_CONTROLS.textRevealDelay}`
          )
          .to(
            ".line-1",
            { y: -120, ease: "none" },
            `afterExpand+=${ANIMATION_CONTROLS.textRevealDelay}`
          )
          .to(
            ".line-2",
            { y: -70, ease: "none" },
            `afterExpand+=${ANIMATION_CONTROLS.textRevealDelay}`
          )
          .to(
            ".line-3 span",
            { y: -40, ease: "none" },
            `afterExpand+=${ANIMATION_CONTROLS.textRevealDelay}`
          );

        // Ensure gallery items start offset above viewport so they are hidden visually
        // Set initial progressive offsets for gallery items: first y=0, next y=-50, etc.
        galleryItems.forEach((item, index) => {
          const offset = ANIMATION_CONTROLS.galleryItemOffset * (index + 1); // controlled by galleryItemOffset
          gsap.set(item, { autoAlpha: 1, y: offset, scale: 0.98 });
        });

        // CTA initial state (hidden slightly below)
        const ctaEl = document.querySelector(".hero-cta");
        if (ctaEl) {
          gsap.set(ctaEl, { opacity: 0, y: 12, scale: 0.98 });
        }

        // Reveal the gallery (ensure it's visible even if some items are hidden on mobile)
        gallery.style.visibility = "visible";
        if (document.body.classList.contains("no-js")) {
          document.body.classList.remove("no-js");
        }
      }

      // Build timelines initially AFTER gallery images are loaded to avoid flicker
      function waitForGalleryImages() {
        const images = gsap.utils.toArray(".gallery img");
        return Promise.all(
          images.map((img) => {
            if (img.complete && img.naturalWidth !== 0)
              return Promise.resolve();
            return new Promise((resolve) => {
              img.addEventListener("load", resolve);
              img.addEventListener("error", resolve);
            });
          })
        );
      }

      waitForGalleryImages()
        .then(() => {
          buildTimelines();
          // buildTimelines() sets initial positions; reveal gallery now
          document.querySelector(".gallery").style.visibility = "visible";
          if (document.body.classList.contains("no-js"))
            document.body.classList.remove("no-js");
        })
        .catch(() => {
          // Fallback: if something goes wrong, at least build timelines
          buildTimelines();
          document.querySelector(".gallery").style.visibility = "visible";
          if (document.body.classList.contains("no-js"))
            document.body.classList.remove("no-js");
        });

      // REFRESH ON RESIZE AND RECALCULATE (rebuild timelines)
      let resizeTimeout;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          // refresh ScrollTrigger and rebuild all timelines with new measurements
          ScrollTrigger.refresh();
          buildTimelines();
          // Also ensure heroSection height recalculated (in case of orientation change)
          const desiredHeight = Math.ceil(
            (ANIMATION_CONTROLS.videoScrollDistance + 1) * window.innerHeight
          );
          heroSection.style.height = `${desiredHeight}px`;
        }, 250);
      });

      console.log(
        "ðŸŽ¯ Hero Section - Animations: video, gallery, text parallax loaded."
      );
    </script>
  </body>
</html>
